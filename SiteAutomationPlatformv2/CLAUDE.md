# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

---

## üö® CRITICAL DATABASE RULES - READ FIRST

### **NEVER USE `form_sql` TABLE - IT IS DEPRECATED**

üìñ **Full Database Reference**: See [docs/DATABASE_TABLES_REFERENCE.md](docs/DATABASE_TABLES_REFERENCE.md) for complete table schemas and code examples.

### **Page-Specific Database Tables:**

**Page 2 (Equipment):**
- ‚úÖ **USE**: `equipmentDAL.js` ‚Üí accesses `equipment_aerotherme`, `equipment_climate`, `equipment_rooftop`, `equipment_lighting`
- ‚ùå **NEVER**: Write direct SQL queries for equipment data
- ‚ùå **NEVER**: Use `form_sql` table

**Page 5 (GTB Configuration):**
- ‚úÖ **USE**: `gtbConfigDAL.js` ‚Üí accesses `gtb_modules`, `gtb_module_references`
- ‚ùå **NEVER**: Mix equipment tables with GTB tables

**Key Points:**
1. Equipment tables are **zone-aware** (support multiple zones per site)
2. GTB tables are **devis-aware** (support multiple devis per site)
3. Always use DAL (Data Access Layer) - never write raw SQL
4. Zone-suffixed fields like `nb_aerotherme_surface_de_vente` are automatically generated by DAL

---

## Development Commands

### Frontend Commands
- `npm run dev` - Start development server with Vite HMR
- `npm run build` - Build for production using Vite
- `npm run preview` - Preview production build locally
- `npm run lint` - Run ESLint on codebase

### Backend Commands  
- `npm run server` - Start Express.js backend server on port 4001 (runs server.js)

### Testing Commands
- `npm run test` - Run core API tests (test/api/test-core.js)
- `npm run test:quick` - Run quick validation tests
- `npm run test:core` - Run core functionality tests
- `npm run test:advanced` - Run advanced API tests
- `npm run test:interactive` - Run interactive test runner
- `npm run test:with-server` - Auto-start server and run tests
- `npm run test:debug` - Run debug test runner

## Design Philosophy & Intended Architecture

**üìä Architecture Documentation**: See [docs/ARCHITECTURE_DIAGRAM.md](docs/ARCHITECTURE_DIAGRAM.md) for comprehensive system diagrams

### Core Principles
This application embodies a **site-centric, workflow-driven architecture** designed for technical professionals managing building automation systems. The intended design prioritizes:

1. **Progressive Disclosure**: Users move through a logical sequence (Site Info ‚Üí Equipment ‚Üí Visual Planning ‚Üí Devis ‚Üí GTB Configuration) with each page building upon the previous
2. **Contextual Persistence**: Every action is tied to a specific site, ensuring data isolation and professional workflow continuity
3. **Visual-First Approach**: Complex technical data is transformed into intuitive visual representations (draggable icons, interactive plans, polygon editors)
4. **Offline-First Mentality**: Local state management with periodic synchronization, allowing uninterrupted work even with connectivity issues
5. **Professional Tool Standards**: Enterprise-grade reliability with comprehensive testing, error handling, and data validation

### Intended User Experience
The application is designed as a **digital technical worksheet** that mirrors real-world site assessment workflows:
- **Page 1-2**: Gather basic site information and catalog existing equipment
- **Page 3-4**: Create visual documentation and surface analysis  
- **Page 5-6**: Design and plan new automation systems

Each page should feel like a specialized tool while maintaining consistent patterns and familiar navigation.

### Future Vision
- **Multi-site Dashboard**: Centralized view of all sites with status indicators and progress tracking
- **Template System**: Reusable configurations for common building types and equipment setups  
- **Collaboration Features**: Multi-user editing with role-based permissions and change tracking
- **Advanced Analytics**: Equipment utilization reports, cost analysis, and efficiency recommendations
- **Mobile Companion**: Field-optimized mobile app for on-site data collection and updates
- **API Integration**: Connect with manufacturer databases, pricing systems, and project management tools

## Architecture Overview

This is a full-stack React application for managing site information and technical equipment across multiple pages. The application combines a React frontend with an Express.js backend and MySQL database.

### Frontend Structure
- **Framework**: React 18 with Vite as the build tool
- **UI Library**: Ant Design (antd) with Pro Components for advanced UI elements
- **Routing**: React Router DOM with tab-based navigation (6 main pages)
- **State Management**: React hooks with localStorage persistence for form data
- **Drag & Drop**: React DND for interactive plan editing
- **Canvas**: Konva/React-Konva for 2D graphics manipulation

### Page Structure
1. **SiteInfoPage** (Page 1 - Site Info): Basic site information form with MySQL persistence
2. **EquipmentPage** (Page 2 - Site Equipment): Interactive catalog of technical equipment featuring dynamically generated cards, automatically populated from SQL data, with responsive category selection, structured per-section field grouping, and real-time updates on data refresh.
3. **VisualPlanPage** (Page 3 - VT Plan): Interactive visual plan editor for site images, allowing users to upload, crop, and overlay draggable icons. Supports saving both grayscale and annotated images to SQL and ImgBB, deleting them from both, also saving icon positions in SQL, and restoring previously saved layouts with accurate icon positions based on shapes stored in SQL. Automatically restores the grayscale background and each icon's correct location when a saved layout exists.

4. **SurfacePlanPage** (Page 4 - Surface Plan / Polygon Editor): Interactive site surface editor allowing users to create, crop, and manage multiple cards with polygonal areas. Supports uploading each card to SQL and ImgBB, deleting individual or all cards from both, and restoring previously saved polygon positions and images per site. Integrates real-time polygon drawing tools, color selection, and dynamic card management for precise site mapping.
5. **GtbConfigPage** (Page 5 - GTB Site): Comprehensive building automation system setup interface. Allows specifying quantities of modules and sensors, managing associated references, and dynamically handling multiple module types. Saving all data to SQL, and restoring previously stored values on reload. Interactive forms ensure real-time validation and consistent reference mapping per module type.
6. **GtbPlanPage** (Page 6 - GTB Plan): Interactive site plan editor for building automation. Allows uploading and cropping a background image, overlaying draggable modules, and generating a grayscale base image. Saves both image and module positions to SQL and ImgBB. Restores previous module positions and image if already stored, ensuring accurate alignment based on saved coordinates.
### Backend Architecture
- **Server**: Express.js with comprehensive middleware (helmet, cors, morgan) - `server.js` (root level)
- **Port Configuration**: Backend runs on **port 4001** (changed from 3001 for production deployment)
- **Database**: MySQL with connection pooling for site data and image metadata
- **Image Handling**: ImgBB integration for image uploads with local multer processing
- **API Structure**: RESTful endpoints for CRUD operations on site data
- **Routes Organization**: Image routes separated into `/routes/imageRoutes.js`
- **Error Handling**: Comprehensive try-catch blocks with detailed logging
- **Data Validation**: Input validation and sanitization on all endpoints
- **Testing**: Organized test suite in `/test/` directory with API and runner tests

### Key Technical Features
- **Form Persistence**: Automatic localStorage backup with server synchronization
- **Image Management**: Cropping, upload, and deletion with ImgBB cloud storage
- **Multi-step Workflow**: Tab-based navigation preserving state across pages
- **Responsive Design**: Mobile-optimized with Ant Design breakpoints
- **Real-time Updates**: Position tracking for draggable elements

### Testing Architecture
- **Organized Structure**: Tests separated into `/test/api/` and `/test/runners/`
- **Core Tests**: Basic API functionality validation (`test-core.js`)
- **Quick Tests**: Fast validation suite (`test-quick.js`) 
- **Advanced Tests**: Complex functionality testing (`test-advanced.js`)
- **Interactive Runner**: User-friendly test interface (`test-runner.js`)
- **Debug Tools**: Specialized debugging test runner (`debug-test.js`)
- **Auto-Start**: Tests can automatically start the server when needed

### Database Schema

**üö® CRITICAL: NORMALIZED SCHEMA ONLY - DO NOT USE `form_sql` TABLE**

The application uses a **fully normalized database schema**. The old `form_sql` flat table is deprecated and should NEVER be used.

#### **Database Tables by Page**

##### **Page 1 - Site Information**
- `sites` - Main site information table
  - Fields: `id`, `site_name`, `client_name`, `address`, `phone_primary`, `phone_secondary`, `email`, `created_at`, `updated_at`

##### **Page 2 - Equipment (ZONE-AWARE)**
**üîë KEY POINT: Page 2 uses NORMALIZED EQUIPMENT TABLES via `equipmentDAL`**

**ALWAYS use `database/dal/equipmentDAL.js` for Page 2 data access. NEVER write direct SQL queries.**

Equipment tables:
- `equipment_aerotherme` - Aerotherme equipment configuration
  - Fields: `site_name`, `zone_aerotherme`, `nb_aerotherme`, `thermostat_aerotherme`, `nb_contacts_aerotherme`, `coffret_aerotherme`, `coffret_horloge_aerotherme`, `type_aerotherme`, `fonctionement_aerotherme`, `maintenance_aerotherme`, `commentaire_aero`, `td_aerotherme`
  - **Zone field**: `zone_aerotherme` (e.g., 'surface_de_vente', 'bureau', 'reserve')

- `aerotherme_references` - Aerotherme brand references
  - Fields: `site_name`, `zone_aerotherme`, `brand_index`, `brand_name`
  - Links to parent aerotherme equipment by zone

- `equipment_climate` - Climate control equipment
  - Fields: `site_name`, `zone_clim`, `nb_clim_ir`, `nb_clim_wire`, `coffret_clim`, `type_clim`, `fonctionement_clim`, `maintenance_clim`, `nb_telecommande_clim_smartwire`, `nb_telecommande_clim_wire`, `commentaire_clim`, `td_clim`
  - **Zone field**: `zone_clim`

- `climate_references` - Climate equipment references
  - Fields: `site_name`, `ref_type` ('clim_ir' | 'clim_wire'), `ref_index`, `ref_value`

- `equipment_rooftop` - Rooftop equipment
  - Fields: `site_name`, `zone_rooftop`, `zone_rooftop_1`, `zone_rooftop_2`, `zone_rooftop_3`, `zone_rooftop_4`, `nb_rooftop`, `thermostat_rooftop`, `telecomande_modbus_rooftop`, `coffret_rooftop`, `type_rooftop`, `type_rooftop_1`, `type_rooftop_2`, `type_rooftop_3`, `fonctionement_rooftop`, `maintenance_rooftop`, `commentaire_rooftop`
  - **Zone field**: `zone_rooftop`

- `rooftop_references` - Rooftop brand references
  - Fields: `site_name`, `brand_index`, `brand_name`

- `equipment_lighting` - Lighting equipment (NO ZONES)
  - Fields: `site_name`, `eclairage_interieur`, `eclairage_contacteur`, `eclairage_exterieur`, `eclairage_horloge`, `commentaire_eclairage`

**Page 2 Data Access Pattern:**
```javascript
// ‚úÖ CORRECT - Use equipmentDAL
import equipmentDAL from '../../database/dal/equipmentDAL.js';

const aeroData = await equipmentDAL.getAerothermeData(siteName);
const climData = await equipmentDAL.getClimateData(siteName);
const rooftopData = await equipmentDAL.getRooftopData(siteName);
const lightingData = await equipmentDAL.getLightingData(siteName);

// ‚ùå WRONG - Never write direct SQL for Page 2
const [rows] = await db.execute('SELECT * FROM equipment_aerotherme WHERE site_name = ?', [siteName]);
```

**Zone-Aware Data Format:**
- Equipment with zones returns zone-suffixed fields: `nb_aerotherme_surface_de_vente: 3`
- Frontend `groupDataByZones()` detects these suffixes and creates zone-specific cards
- Equipment cards display actual zone names instead of "G√©n√©ral"

##### **Page 5 - GTB Configuration**
**üîë KEY POINT: Page 5 uses GTB TABLES via `gtbConfigDAL`**

**ALWAYS use `database/dal/gtbConfigDAL.js` for Page 5 data access.**

GTB tables:
- `gtb_modules` - GTB module configuration per site/devis
  - Fields: `site_name`, `devis_name`, `module_type`, `quantity`, `refs`, `sondes`, `sondes_presentes`, `gaz_compteur`, `izit`
  - Supports multiple devis per site

- `gtb_module_references` - Individual module references
  - Fields: `site_name`, `module_type`, `ref_index`, `ref_value`

- `gtb_module_types` - Module type definitions
  - Preloaded lookup table

**Page 5 Data Access Pattern:**
```javascript
// ‚úÖ CORRECT - Use gtbConfigDAL
import gtbConfigDAL from '../../database/dal/gtbConfigDAL.js';

await gtbConfigDAL.saveGtbConfig(siteName, devisName, gtbData);
const gtbConfig = await gtbConfigDAL.getGtbConfig(siteName, devisName);

// ‚ùå WRONG - Never mix Page 2 equipment tables with Page 5 GTB tables
```

##### **Images & Visual Plans (All Pages)**
- `image_sql` - Image metadata and delete URLs
  - Fields: `id`, `site`, `type`, `title`, `url_viewer`, `shapes`, `url_thumb`, `url_medium`, `delete_url`, `datetime`, `card_id`, `x`, `y`, `label`, `image_url`, `comments`, `module_type`, `width`, `height`, `crop_transform_x`, `crop_transform_y`, `crop_transform_width`, `crop_transform_height`, `zone_name`
  - **shapes** field stores icon positions in JSON format: `[{"id":"aero-1","x":150,"y":100},{"id":"aero-2","x":250,"y":100}]` 

### Development Patterns
- Components use Ant Design patterns with Form.useForm() hooks
- API calls centralized in `src/api/` modules (see below)
- Image processing handled via dedicated `routes/imageRoutes.js`
- Modular icon components in dedicated Icon directories
- Shared utilities for upload operations across pages
- Custom hooks extracted for reusability (e.g., `usePersistedState`)
- Clean component organization with descriptive file names

### Recent Improvements (October 2025)

**‚úÖ Code Cleanup & Reorganization**:
1. **Route Consolidation**: Renamed `completeParallelEndpoints.js` ‚Üí `mainRoutes.js` for clarity
2. **Archive Redundant Files**: Moved 5 unused route files to `src/routes/archive/`
3. **Directory Naming**: Renamed `src/pages/vtPlan/` ‚Üí `src/pages/VisualPlan/` for consistency
4. **File Extensions**: Fixed `equipment/constants.jsx` ‚Üí `constants.js` (pure JS, no JSX)
5. **Server.js Optimization**: Removed 208 lines of duplicate code (31.6% reduction)
6. **Unused Imports**: Cleaned up deprecated utilities

**üìä Quality Metrics**:
- Test Coverage: 100% (5/5 quick tests passing)
- Code Quality Grade: B+ ‚Üí A (in progress)
- See [docs/ARCHITECTURE_AUDIT_2025_10_15.md](docs/ARCHITECTURE_AUDIT_2025_10_15.md) for full audit

### Architectural Principles & Intended Patterns

#### üéØ **Site-Centric Data Model** (Enforced)
```
Every data operation MUST be tied to a site identifier:
- localStorage: `currentSite` or `simpleFormData.site`
- SQL queries: WHERE site = ?
- API endpoints: POST /get-page2 with { site: "siteName" }
- File uploads: Tagged with site metadata
```

#### üîÑ **Consistent State Flow Pattern** (Intended)
```
1. Mount ‚Üí Check localStorage for site context
2. Fetch ‚Üí Query SQL for existing data  
3. Populate ‚Üí Auto-load into UI state if exists
4. Edit ‚Üí Local changes only (no real-time sync)
5. Save ‚Üí Explicit user action pushes to SQL+ImgBB
6. Clean ‚Üí Reset local state after successful save
```

#### üèóÔ∏è **Component Architecture Standards**
- **Page Components**: Handle routing, site context, and high-level state
- **Feature Components**: Manage specific functionality (ImageCropper, DraggableCardList)
- **Utility Functions**: Centralized logic for uploads, transformations, API calls
- **Custom Hooks**: Shared stateful logic (usePersistedState, useCardManager)

#### üìä **Data Persistence Strategy**
```
Dual-Layer Persistence:
- localStorage: Temporary, cross-page state (site context, form drafts)
- MySQL + ImgBB: Permanent, authoritative data storage
- Sync Pattern: Pull on mount, push on save, never continuous
```

#### üé® **Visual Consistency Standards**
- Ant Design as the single UI framework
- Consistent spacing: 16px grid system
- Mobile-first responsive breakpoints
- Icon standardization across all pages
- Color palette: Professional blues and grays with accent colors for status

#### üîß **Intended Code Organization** 
```
src/
‚îú‚îÄ‚îÄ pages/           # Page-level components (SiteInfoPage, EquipmentPage, etc.)
‚îú‚îÄ‚îÄ components/      # Reusable feature components  
‚îú‚îÄ‚îÄ utils/          # Pure functions and API utilities
‚îú‚îÄ‚îÄ hooks/          # Custom React hooks
‚îú‚îÄ‚îÄ icons/          # Modular icon components
‚îî‚îÄ‚îÄ styles/         # Global styles and themes (future)
```

---

## Detailed Page Workflows

### üîë General Workflow Pattern (Site-Based with SQL Sync)

All pages (Page 2 ‚Üí Page 6) follow this consistent pattern:

1. **Site Context First**: Check `currentSite` or `simpleFormData` from localStorage (fallback: "unknown")
2. **SQL Check on Mount**: Query SQL for existing data for this site
3. **Auto-Populate if Exists**: Load saved data into UI state automatically
4. **Fallback to Empty**: Initialize with empty fields if no SQL data
5. **Local Editing**: Changes affect React state only (no real-time SQL sync)
6. **Persistence on Save**: Explicit save action uploads to ImgBB + saves metadata to SQL
7. **Cleanup/Deletion**: Remove from both ImgBB and SQL, reset local state

### EquipmentPage Workflow (Page 2) - Technical Implementation

### Step 1: Site Name Retrieval
- Reads `simpleFormData` from localStorage
- Extracts `site` ‚Üí used as the identifier for SQL queries
- Fallback: "unknown" if nothing is found

### Step 2: SQL Check & Auto-Population
On mount and whenever siteName changes:
- `POST /get-page2` ‚Üí fetches existing form data from `form_sql` table
- `POST /images/get-sql-images` ‚Üí fetches existing image metadata from `image_sql` table
- If data exists: auto-populates form fields and selects categories with data
- If no data: initializes empty state for new configuration

### Step 3: Data Grouping & Processing
Sections = [Aero, Clim, Rooftop, Eclairage]

Fields are grouped explicitly by column-to-icon mapping:
- `nb_aerotherme` ‚Üí `Icon_aerotherme`
- `nb_clim_ir` ‚Üí `Icon_clim_ir`
- `nb_clim_wire` ‚Üí `Icon_clim_wire`
- `nb_rooftop` ‚Üí `Icon_rooftop`
- `coffret_aerotherme` ‚Üí `Icon_coffret_aerotherme`
- `coffret_clim` ‚Üí `Icon_coffret_clim`
- `nb_telecommande_clim_wire` ‚Üí `Icon_nb_telecommande_clim_wire`
- `circle` ‚Üí `Icon_circle`

### Step 5: Category Selection Logic
- If no SQL data ‚Üí all categories unchecked
- If SQL data exists ‚Üí only categories with data are checked
- User can still manually toggle categories

### Step 6: Rendering Cards
- Shows one `EditableCard` at a time (`currentSlideIndex` determines which)
- If no categories selected ‚Üí `<Empty />` placeholder
- If selected ‚Üí passes title + stored `editableData[section]` into `EditableCard`

### Persistence Model
- `form_sql` ‚Üí permanent storage for form fields
- `image_sql` ‚Üí permanent storage for uploaded images
- Save flow uses `POST /save_page2` to persist back into `form_sql`

### Extra Observations
- Two useEffect hooks perform similar fetch logic ‚Üí possible refactor target
- Grouping is tied to this explicit field-to-icon map rather than flexible schema
- Navigation uses progressive disclosure: only one card visible at a time

---

### EquipmentPage Workflow (Page 2) - User Flow

Step 1: Site Name Retrieval

When you open Page 2, the app reads simpleFormData from localStorage to determine which site you are working on.

It extracts the site name, which will be used as a key for SQL queries (both form_sql for fields and image_sql for images).

If the site is missing, it defaults to "unknown" to prevent errors.

Step 2: Automatic State Initialization

selectedOptions is a state array that tracks which equipment categories are currently active (Aero, Clim, Rooftop, Eclairage).

editableData is a state object storing the actual field values for each category.

When the page first loads, both are empty. They will be automatically populated based on SQL data.

Step 3: Automatic Data Fetching from SQL

On first mount (or when siteName changes), the page sends API requests:

POST /get-page2 ‚Üí retrieves form field values for this site from form_sql.

POST /images/get-sql-images ‚Üí retrieves any stored image metadata from image_sql.

The response is used to pre-populate the UI:

If nb_aerotherme exists in SQL (e.g., 5), then:

selectedOptions automatically includes Aero.

editableData.Aero contains 5 editable fields for aero thermes, filled with the SQL values.

Same logic applies to nb_clim_ir, nb_clim_wire, nb_rooftop, etc., filling the respective categories and their editable areas.

If a field in SQL is empty or missing, the corresponding editable area remains empty so the user can fill it manually.

This automatic population happens only once per page load. After that, the UI state is independent of SQL until the page is refreshed or revisited.

Step 4: Data Grouping & Field-to-Icon Mapping

Each numeric field from SQL corresponds to a visual icon in the plan:
nb_aerotherme ‚Üí Icon_aerotherme
nb_clim_ir ‚Üí Icon_clim_ir
nb_clim_wire ‚Üí Icon_clim_wire
nb_rooftop ‚Üí Icon_rooftop
coffret_aerotherme ‚Üí Icon_coffret_aerotherme
coffret_clim ‚Üí Icon_coffret_clim
nb_telecommande_clim_wire ‚Üí Icon_nb_telecommande_clim_wire
circle ‚Üí Icon_circle
This mapping ensures that any numeric values from SQL translate directly into visual representations on the page.
Step 5: Category Selection Logic
If a category has SQL data, it‚Äôs automatically checked in selectedOptions.
If a category has no SQL data, it‚Äôs unchecked.
Users can toggle categories manually to show or hide them, independent of SQL until saved.
Step 6: Editable Cards Rendering
Only one EditableCard is displayed at a time (like a carousel).
Each card shows the title and the editableData for that category.
If no category is selected, an <Empty /> placeholder is displayed.
Users can edit existing values (from SQL) or fill empty fields for new modules.
Step 7: Persistence
All changes are saved to SQL when the user clicks save (POST /save_page2).
Form fields go into form_sql; images go into image_sql.
Until the user explicitly saves, the UI state is local and independent. SQL only syncs on page load or refresh.
Key Points / Observations
Automatic population ensures consistency between SQL and UI on first load.
Editable fields always reflect the SQL counts, but user edits are independent until saved.
Only one fetch per load ‚Üí no continuous syncing with SQL, minimizing API calls.
The system allows for progressive disclosure: categories appear dynamically based on SQL or user selection.

---

### VisualPlanPage Workflow (Page 3 - VT Plan / Draggable Icons)

**Follows the General Pattern:**

Step 1: Site Context & SQL Check
- Reads `simpleFormData` from localStorage, extracts site name (fallback: "unknown")
- On mount: queries SQL for existing grayscale image and shapes JSON for this site
- If exists: auto-loads background image and restores all icon positions
- If not: initializes empty state for new plan creation

Step 2: State Management
- `imageSrc` ‚Üí original uploaded image
- `croppedImage` ‚Üí base64 grayscale background (auto-loaded from SQL or newly uploaded)
- `shapes` ‚Üí array of draggable icons with {id, x, y} positions (restored from SQL)
- `imageNaturalWidth/imageDisplayedWidth` ‚Üí for scaling calculations

Step 3: Local Editing (Image & Icons)
- User can upload/crop new background image via ImageCropperModal
- Drag icons to reposition them (updates shapes state locally)
- Icon count driven by Page 2 equipment data (nb_aerotherme, nb_clim_ir, etc.)
- All changes stay in React state until save

Step 4: Persistence (Save Action)
- `handleSubmit()` generates final annotated image via html2canvas
- Uploads both grayscale and annotated versions to ImgBB
- Saves image URLs, crop transforms, dimensions, and shapes JSON to `image_sql`
- Overwrites any existing plan for this site

Step 5: Cleanup/Deletion
- `handleRemove()` deletes images from ImgBB using delete URLs
- Removes SQL metadata, resets local state for fresh start

**Dependencies:**
- DraggableCardList, ImageCropperModal, uploadUtils.js, imageUtils.js

---

### SurfacePlanPage Workflow (Page 4 - Surface Plan / Polygon Cards)

**Follows the General Pattern:**

Step 1: Site Context & SQL Check
- Reads `currentSite` from localStorage (fallback: "unknown")
- On mount: queries SQL for existing surface cards for this site
- If cards exist: auto-loads all cards with their images and polygon data
- If not: initializes empty state for new card creation

Step 2: State Management (via useCardManager hook)
- `cards` ‚Üí array of surface cards with images and polygons
- `polygonPoints` ‚Üí coordinates for active polygon drawing
- `drawingColor` ‚Üí selected color for current polygon
- `activeDrawingCardIndex` ‚Üí which card is being edited
- `deleteUrls` ‚Üí ImgBB delete URLs for cleanup

Step 3: Local Editing (Cards & Polygons)
- User uploads/crops images for new cards via ImageCropperModal
- Draw polygons on each card using PolygonDrawingControls
- Modify polygon points, colors, and properties
- All changes stay in React state until save

Step 4: Persistence (Upload Action)
- `handleUpload()` uploads all card images to ImgBB
- Saves card metadata, polygons coordinates to `image_sql`
- Multiple cards can be saved per site

Step 5: Cleanup/Deletion
- `handleRemove(index)` deletes single card from ImgBB + SQL
- `handleDeleteAll()` removes all surface cards for the site
- Resets local state for fresh start

**Dependencies:**
- CardEditor, PolygonDrawingControls, ImageCropperModal, uploadUtils.js, deleteSurfaceCard

---

### GtbConfigPage Workflow (Page 5 - GTB Site / Module Configuration)

**Follows the General Pattern:**

Step 1: Site Context & SQL Check
- Reads `currentSite` from localStorage (fallback: "unknown")
- On mount: queries SQL for existing GTB module configuration for this site
- If exists: auto-populates form fields and selectedModules array
- If not: initializes empty form for new module setup

Step 2: Dynamic Form Management
- Form auto-generates input fields based on module counts
- Reference arrays dynamically match module quantities
- Handles special modules: sondes, sondesPresentes, gazCompteur, Izit

Step 3: Local Editing (Module Configuration)
- User selects modules via multi-select interface
- Specifies quantities and references for each module type
- Form validation ensures data consistency
- All changes stay in form state until save

Step 4: Persistence (Save Action)
- `handleSubmit()` validates and posts data to `save_page3` endpoint
- Saves all module counts, references, and metadata to `form_sql`
- Overwrites existing GTB configuration for this site

Step 5: Reset/Reload
- User can clear form and reload from SQL
- Maintains form state independence from SQL until save

**Dependencies:**
- Ant Design ‚Üí form controls, cards, layout, messaging
- Axios ‚Üí backend communication for saving and retrieving SQL data
---

### GtbPlanPage Workflow (Page 6 - GTB Plan / Draggable Components)

**Follows the General Pattern:**

Step 1: Site Context & SQL Check
- Reads `currentSite` from localStorage (fallback: "unknown")
- On mount: queries SQL for existing GTB plan image and module positions
- If exists: auto-loads grayscale background and restores all module positions
- If not: initializes empty state for new GTB plan creation

Step 2: Local Editing (GTB Plan & Modules)
- User uploads/crops background image via ImageCropperModal
- Drag GTB modules to position them on the plan
- Module types and counts driven by Page 5 configuration
- All changes stay in React state until save

Step 3: Persistence (Save Action)
- `handleSubmit()` generates final GTB plan via html2canvas
- Uploads annotated image to ImgBB
- Saves image URLs, crop transforms, module positions to `image_sql`
- Overwrites existing GTB plan for this site

Step 4: Cleanup/Deletion
- `onRemove()` deletes images from ImgBB and SQL metadata
- Resets local state for fresh GTB plan creation

**Dependencies:**
- ImageCropperModal ‚Üí cropping workflow
- DraggableCardList ‚Üí icons/modules overlay & drag logic
- html2canvas ‚Üí overlay rendering for final annotated image
- ImgBB + SQL ‚Üí persistence for images and module data

---

## üîß Critical Configuration & Port Information

### **Backend Server Configuration**
- **Current Port**: **4001** (production deployment port)
- **Previous Port**: 3001 (deprecated, updated 2025-09-09)
- **Server URL**: `http://localhost:4001`
- **Frontend URL**: `http://localhost:5177` (Vite development server)

### **API Base URL Configuration**
All frontend API calls use the centralized configuration in:
- **Primary Config**: `src/api/apiConfig.js` - `API_BASE_URL = 'http://localhost:4001'`
- **Test Config**: `test/config/test-config.js` - Test suite endpoints
- **Utility Config**: `test/utils/test-helpers.js` - Test helper functions

### **Key Files Updated for Port Change**
The following files contain hardcoded references to port 4001 and must be updated together:
```
‚úÖ UPDATED FILES (Port 4001):
‚îú‚îÄ‚îÄ server.js (main backend server)
‚îú‚îÄ‚îÄ src/api/constants.js (frontend API base URL)
‚îú‚îÄ‚îÄ src/hooks/useCardManager.js (SurfacePlanPage data loading)
‚îú‚îÄ‚îÄ src/pages/surfacePlan/uploadUtils.js (surface plan uploads)
‚îú‚îÄ‚îÄ src/pages/surfacePlan/getDeleteUrlFromSQL.js (delete URL fetching)
‚îú‚îÄ‚îÄ src/pages/surfacePlan/deleteSurfaceCard.js (image deletion)
‚îú‚îÄ‚îÄ test/config/test-config.js (test configuration)
‚îî‚îÄ‚îÄ test/utils/test-helpers.js (test utilities)
```

### **Status Verification Commands**
```bash
# Check if backend is running on correct port
curl -X POST http://localhost:4001/list-sites -H "Content-Type: application/json" -d "{}"

# Test SurfacePlanPage critical endpoint
curl -X POST http://localhost:4001/images/get-sql-images -H "Content-Type: application/json" -d '{"site":"test"}'

# Verify port is listening
netstat -an | findstr :4001
```

### **Troubleshooting Port Issues**
- **Problem**: 404 errors on API calls ‚Üí Check if server is running on port 4001
- **Solution**: Restart server with `npm run server`
- **Problem**: Frontend can't connect ‚Üí Verify `src/api/constants.js` has correct port
- **Problem**: SurfacePlanPage not working ‚Üí Check all surfacePlan/* files use port 4001

---

## API Endpoints

**Base URL**: `http://localhost:4001` (All endpoints run on port 4001)

### Site Information Endpoints (Page 1)
- `POST /save-page1` - Save SiteInfoPage data (UPSERT to `sites` table)
- `POST /get-page1` - Retrieve SiteInfoPage data by site name
- `POST /list-sites` - Get all site names for autocomplete/dropdown

### Equipment Endpoints (Page 2) - Via equipmentDAL
- `POST /save_page2` - Save EquipmentPage data (saves to normalized equipment tables)
  - Backend uses `equipmentDAL.saveEquipmentData()` internally
  - Supports zone-aware data with zone suffixes
- `POST /get-page2` - Retrieve EquipmentPage data (zone-aware)
  - Backend uses `equipmentDAL.getAerothermeData()`, `getClimateData()`, etc.
  - Returns zone-suffixed fields: `nb_aerotherme_surface_de_vente: 3`
  - Frontend `groupDataByZones()` processes these into zone-specific cards

### GTB Configuration Endpoints (Page 5) - Via gtbConfigDAL
- `POST /save_page3` - Save GtbConfigPage module configuration
  - Backend uses `gtbConfigDAL.saveGtbConfig(site, devis, gtbData)`
  - Saves to `gtb_modules` and `gtb_module_references` tables
- `POST /get-page3` - Retrieve GTB configuration
  - Backend uses `gtbConfigDAL.getGtbConfig(site, devis)`
  - Returns flat format compatible with frontend forms

### Image Endpoints (via /images router)
- `POST /images/upload` - Upload image to ImgBB
- `POST /images/save-to-sql` - Save image metadata to SQL
- `POST /images/get-sql-images` - Get all images for a site
- `POST /images/delete-from-sql` - Delete image metadata from SQL
- `DELETE /images/delete-from-imgbb` - Delete image from ImgBB
- `POST /images/get-delete-url` - Get ImgBB delete URLs for cleanup

---

## Development Best Practices & Guidelines

### üöÄ **Getting Started (New Developer Onboarding)**
```bash
# 1. Install dependencies
npm install

# 2. Start development servers (2 terminals)
npm run server    # Backend (port 4001)  
npm run dev       # Frontend (port 5177)

# 3. Run tests to verify setup
npm run test:quick

# 4. Optional: Start with test data
# Visit Page 1, create a site, move through pages 2-6
```

### üîç **Debugging Workflow**
```bash
# Backend debugging
npm run test:debug           # Interactive debugging
npm run test:with-server     # Full integration tests

# Frontend debugging  
npm run dev                  # Hot reload development
# Browser DevTools ‚Üí Sources ‚Üí Pause on exceptions
# Check localStorage for site context issues
# Verify SQL responses in Network tab
```

### üìù **Code Standards & Conventions**

#### Component Naming
```javascript
// ‚úÖ Correct: Descriptive, PascalCase
SiteInfoPage.jsx
EquipmentPage.jsx  
ImageCropperModal.jsx
DraggableCardList.jsx

// ‚ùå Avoid: Generic or unclear names
Page1.jsx
Modal.jsx
List.jsx
```

#### API Patterns
```javascript
// ‚úÖ Consistent site-based queries
const response = await fetchAPI('/get-page2', { site: currentSite });

// ‚úÖ Proper error handling
try {
  const data = await uploadToImgBB(imageFile);
  // Handle success
} catch (error) {
  console.error('Upload failed:', error);
  // Show user-friendly message
}

// ‚ùå Avoid: Queries without site context
const response = await fetchAPI('/get-all-data');
```

#### State Management
```javascript
// ‚úÖ Site context from localStorage
const siteName = simpleFormData?.site || currentSite || "unknown";

// ‚úÖ Local editing with explicit saves  
const [localData, setLocalData] = useState({});
const handleSave = () => submitToSQL(localData);

// ‚ùå Avoid: Immediate SQL updates on every change
onChange={(value) => updateDatabase(value)}
```

### üß™ **Testing Strategy**
```bash
# Test Pyramid (recommended frequency)
npm run test:quick      # ‚ö° Run before every commit
npm run test:core       # üîç Run daily during development  
npm run test:advanced   # üöÄ Run before releases
npm run test:interactive # üéØ Run when debugging specific issues
```

### üêõ **Common Pitfalls & Solutions**

#### Issue: Site Context Missing
```javascript
// üö® Problem: Page loads with undefined site
const siteName = undefined;

// ‚úÖ Solution: Always provide fallback
const siteName = simpleFormData?.site || currentSite || "unknown";
```

#### Issue: Image Upload Failures  
```javascript
// üö® Problem: ImgBB upload without error handling
await uploadToImgBB(file);

// ‚úÖ Solution: Comprehensive error handling
try {
  const result = await uploadToImgBB(file);
  if (!result?.data?.url) throw new Error('Upload response missing URL');
  return result.data.url;
} catch (error) {
  console.error('ImgBB upload failed:', error);
  message.error('Image upload failed. Please try again.');
  throw error;
}
```

#### Issue: State Synchronization Problems
```javascript
// üö® Problem: Stale state after SQL updates
const [data, setData] = useState(initialData);
// ... user saves to SQL, but local state not updated

// ‚úÖ Solution: Sync local state after successful saves
const handleSave = async () => {
  try {
    await submitToSQL(data);
    message.success('Saved successfully');
    // Optionally refresh from SQL or keep local state
  } catch (error) {
    message.error('Save failed');
  }
};
```

### üìä **Performance Guidelines**

#### Image Optimization
- **Cropping**: Always crop images before upload to reduce file size
- **Format**: Use WebP when possible, fallback to JPEG
- **Dimensions**: Limit max dimensions to 2048x2048px for plans
- **Cleanup**: Always delete unused images from ImgBB

#### State Management
- **Lazy Loading**: Don't fetch all sites on app load
- **Debouncing**: Debounce rapid user inputs (drag operations)
- **Memory**: Clear large image data from state after upload

#### Database Queries
- **Site-Scoped**: Every query should include site filter
- **Batch Operations**: Group related updates together
- **Connection Pooling**: Already implemented in server.js

### üîß **IDE Setup Recommendations**
```json
// .vscode/settings.json (recommended)
{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "emmet.includeLanguages": {
    "javascript": "javascriptreact"
  }
}
```

### üì¶ **Dependency Management**
```bash
# Adding new dependencies (check existing usage first)
npm list | grep -i [package-name]   # Check if already included
npm install [package] --save        # Add to dependencies
npm install [package] --save-dev    # Add to devDependencies

# Security updates
npm audit                           # Check for vulnerabilities  
npm audit fix                       # Auto-fix when possible
```

---

## üìù Naming Conventions & Code Standards

### File Naming
- **Pages**: `PascalCase.jsx` (e.g., `SiteInfoPage.jsx`, `EquipmentPage.jsx`)
- **Components**: `PascalCase.jsx` (e.g., `EditableCard.jsx`, `ImageCropperModal.jsx`)
- **Utilities**: `camelCase.js` (e.g., `imageUtils.js`, `siteContext.js`)
- **Constants**: `camelCase.js` or `constants.js` (use `.js` not `.jsx` for pure data)
- **Hooks**: `useCamelCase.js` (e.g., `useSiteContext.js`, `usePersistedState.js`)

### Directory Naming
- **Component Folders**: `PascalCase` (e.g., `VisualPlan/`, `Equipment/`)
- **Utility Folders**: `camelCase` (e.g., `utils/`, `config/`)
- **Plural for Collections**: `icons/`, `hooks/`, `pages/` (not singular)

### Route Naming (Future)
- **URLs**: `kebab-case` (e.g., `/site-info`, `/visual-plan`) - Not yet implemented
- **Current**: Generic `/page1`, `/page2` (legacy, to be updated)

### Import Alias Conventions
```javascript
// ‚úÖ GOOD: Descriptive imports matching file names
import SiteInfoPage from './pages/SiteInfoPage';
import EquipmentPage from './pages/EquipmentPage';

// ‚ùå AVOID: Generic aliases
import Page1 from './pages/SiteInfoPage';  // Confusing
```

---

## Important Notes

- All pages use the `site` field from SiteInfoPage as the primary identifier
- localStorage is used for temporary state persistence between pages
- SQL operations use UPSERT logic (INSERT ON DUPLICATE KEY UPDATE)
- Images are stored in ImgBB with metadata in MySQL
- Each page can work independently but shares site context
- Form validation happens client-side with Ant Design forms
- Backend includes comprehensive error handling and logging
- Custom hooks like `usePersistedState` improve code reusability
- Clean component naming convention for better maintainability
- Modular route organization for better code structure
- **Server Location**: Main server file is `server.js` in root directory (not in src/)
- **Testing Suite**: Comprehensive test coverage with multiple test runners and debugging tools
- **Test Organization**: Structured testing with API tests, runners, and interactive debugging

---

## üìÅ Archive Structure (Cleanup 2025-10-14)

The project maintains a clean codebase by archiving completed migrations and legacy files:

### Archive Locations
```
docs/
‚îú‚îÄ‚îÄ examples/                    # Demo components for reference
‚îÇ   ‚îú‚îÄ‚îÄ SaveStatusDemo.jsx
‚îÇ   ‚îî‚îÄ‚îÄ SiteInfoPage_Enhanced.jsx
‚îî‚îÄ‚îÄ archive/
    ‚îî‚îÄ‚îÄ completed-migrations/    # Completed migration documentation
        ‚îú‚îÄ‚îÄ CENTRALIZED_CONFIG_SUMMARY.md
        ‚îú‚îÄ‚îÄ IMPROVEMENTS_COMPLETE.md
        ‚îú‚îÄ‚îÄ QUICK_REFERENCE.md
        ‚îú‚îÄ‚îÄ SAVE_STATUS_IMPLEMENTATION.md
        ‚îú‚îÄ‚îÄ IMPLEMENTATION_COMPLETE.md
        ‚îú‚îÄ‚îÄ FINAL_SUMMARY.md
        ‚îú‚îÄ‚îÄ VERIFICATION_TEST.md
        ‚îú‚îÄ‚îÄ LOGGING_GUIDE.md
        ‚îú‚îÄ‚îÄ INDEX.md
        ‚îú‚îÄ‚îÄ CLIMATE_FIELD_MAPPING_FIXED.md
        ‚îú‚îÄ‚îÄ VERIFICATION_COMPLETE_2025_10_14.md
        ‚îú‚îÄ‚îÄ deployment_guide.md
        ‚îî‚îÄ‚îÄ run_migration.ps1

database/
‚îî‚îÄ‚îÄ archive/
    ‚îî‚îÄ‚îÄ migration-scripts/       # Legacy SQL migration files
        ‚îú‚îÄ‚îÄ 01_create_normalized_tables.sql
        ‚îú‚îÄ‚îÄ 02_migrate_data.sql
        ‚îú‚îÄ‚îÄ ADD_MISSING_FIELDS_ONLY.sql
        ‚îú‚îÄ‚îÄ complete_schema_fix.sql
        ‚îú‚îÄ‚îÄ COMPLETE_SETUP_FOR_EMPTY_TABLES.sql
        ‚îú‚îÄ‚îÄ critical_schema_fixes.sql
        ‚îú‚îÄ‚îÄ EXACT_TABLES_NEEDED.sql
        ‚îú‚îÄ‚îÄ MIGRATE_YOUR_EXISTING_DATA.sql
        ‚îú‚îÄ‚îÄ migration_improved_schema.sql
        ‚îú‚îÄ‚îÄ POPULATE_EMPTY_EQUIPMENT_TABLES.sql
        ‚îú‚îÄ‚îÄ POPULATE_EQUIPMENT_CATEGORIES.sql
        ‚îú‚îÄ‚îÄ quick_migration.sql
        ‚îú‚îÄ‚îÄ QUICK_TEST_PARALLEL_EQUIPMENT.sql
        ‚îú‚îÄ‚îÄ SAFE_MIGRATE_REAL_DATA.sql
        ‚îú‚îÄ‚îÄ simple_sites_table.sql
        ‚îú‚îÄ‚îÄ SYNC_ALL_EXISTING_DATA.sql
        ‚îî‚îÄ‚îÄ VERIFY_FIELD_MAPPINGS.sql

scripts/
‚îî‚îÄ‚îÄ archive/                     # One-off utility scripts
    ‚îú‚îÄ‚îÄ check-schemas.js
    ‚îú‚îÄ‚îÄ remove-unique-constraints.js
    ‚îî‚îÄ‚îÄ test-all-zones.js
```

### Active Files
- **Migration Scripts**: `database/migration/` contains only active migration files
  - `03_create_additional_normalized_tables.sql` - Current schema
  - `04_migrate_data_to_normalized_tables.sql` - Data migration
  - `backup_before_migration.sql` - Critical backup (DO NOT DELETE)
  - `cleanup-duplicates.sql` - Cleanup utilities
  - `add_zone_to_images.sql` - Zone support
  - `00_run_migration.bat` - Migration runner

- **API Configuration**: Centralized in `src/config/app.config.js`
  - Deprecated `src/api/apiConfig.js` has been removed
  - All imports updated to use centralized config

### Cleanup Notes

#### Phase 1 (October 14, 2025) - Archive Migration
- **Files Archived**: 41 total (12 docs, 17 SQL files, 2 demo pages, 1 deprecated API, 3 utility scripts, 1 PowerShell script)
- **Test Results**: All core tests passing (100% quick test success)
- **Breaking Changes**: None - all active code remains functional

#### Phase 2 (October 14, 2025) - Dead Code Removal
- **Files Removed**: 4 total
  - `src/components/SaveStatus.jsx` (105 lines) - Unused component
  - `src/hooks/useSaveStatus.js` (191 lines) - Unused hook
  - `src/components/layout/ButtonStyles.js` (66 lines) - Unused utility
  - `docs/examples/` directory (576 lines) - Example files
- **Code Quality**:
  - Updated 3 files to remove unnecessary `React` imports (modern JSX transform)
  - Added `test/reports/*.json` to `.gitignore`
- **Total Cleanup**: ~942 lines of dead code removed
- **Test Results**: ‚úÖ 100% quick test success (5/5 passed)
- **Breaking Changes**: None

#### Phase 3 (October 14, 2025) - Conservative Cleanup
- **Files Removed**: 5 total
  - `database/dal/equipmentDAL-zone-methods.js` (468 lines) - Reference file (methods already integrated)
  - `scripts/archive/` directory (163 lines) - Completed utility scripts
  - `advanced-test-report.json` (1,009 lines) - Generated test output
- **Archives Compressed**:
  - `database/archive/migration-scripts/` ‚Üí `migration-scripts-archive-2025-10-14.tar.gz` (80KB ‚Üí 21KB)
  - `docs/archive/completed-migrations/` ‚Üí `completed-migrations-archive-2025-10-14.tar.gz` (148KB ‚Üí 36KB)
- **Documentation Consolidated**:
  - Merged `src/config/README.md` + `MIGRATION_GUIDE.md` ‚Üí `CONFIG.md` (490 lines ‚Üí 150 lines)
- **CSS Cleanup**:
  - Removed Vite template demo styles from `App.css` (~35 lines)
- **Total Cleanup**: ~1,675 lines + 171KB disk space saved
- **Compression Ratio**: 228KB ‚Üí 57KB (75% reduction)
- **Test Results**: ‚úÖ 100% quick test success (5/5 passed)
- **Breaking Changes**: None

#### Phase 4 (October 14, 2025) - Root Directory Organization
- **Files Organized**: 20 files moved from root
- **New Structure**:
  - `scripts/migration/` (8 files) - Migration and sync scripts
  - `scripts/debug/` (4 files) - Debug utilities
  - `scripts/temp-tests/` (8 files) - One-off test scripts
  - `docs/old-design/` (2 files) - Legacy design documentation
- **Files Removed**: 2 temp files (`nul`, `test_parallel_equipment.txt`)
- **Root Directory**: Reduced from 30 files ‚Üí 8 files (73% reduction)
- **Remaining in Root**: Only production essentials
  - `server.js`, `vite.config.js`, `eslint.config.js`
  - `CLAUDE.md`, `README.md`
  - 3 analysis scripts (kept for potential use)
- **Test Results**: ‚úÖ 100% quick test success (5/5 passed)
- **Breaking Changes**: None

---

# üö® CURRENT SYSTEM STATUS (Updated 2025-09-09)

## ‚úÖ **ACTIVE CONFIGURATION**
- **Backend Status**: üü¢ RUNNING on `http://localhost:4001`
- **Frontend Status**: üü¢ RUNNING on `http://localhost:5177` 
- **Database**: üü¢ MySQL connected (localhost:3306)
- **Image Storage**: üü¢ ImgBB integration active

## üîß **CRITICAL PORT MIGRATION COMPLETED**
**Migration Date**: September 9, 2025
**Changed**: Backend port 3001 ‚Üí **4001**
**Reason**: Production deployment readiness
**Status**: ‚úÖ FULLY COMPLETED

### **Verified Working Endpoints**
```bash
‚úÖ http://localhost:4001/list-sites        # Returns: [{"site":"azffffff"},...]
‚úÖ http://localhost:4001/images/get-sql-images  # Returns: [] (empty for test)
‚úÖ All SurfacePlanPage functionality operational
‚úÖ All API routes responding correctly
```

## üéØ **CRITICAL SUCCESS FACTORS**
1. **SurfacePlanPage Resolution**: Port 4001 migration fixed the 404 errors
2. **API Connectivity**: All endpoints now properly configured
3. **Frontend Integration**: `src/api/constants.js` correctly points to port 4001
4. **Test Suite**: All test configurations updated to port 4001

## üìã **DEVELOPER QUICK START**
```bash
# Start both servers (CURRENT WORKING SETUP)
npm run server    # ‚Üí Backend on http://localhost:4001
npm run dev       # ‚Üí Frontend on http://localhost:5177

# Verify system status
curl -X POST http://localhost:4001/list-sites -H "Content-Type: application/json" -d "{}"
# Should return: site data array (not 404)
```

## üö® **TROUBLESHOOTING REMINDERS**
- **404 Errors**: Check if backend is running on port 4001 (not 3001)
- **SurfacePlanPage Issues**: Verify all surfacePlan/*.js files use port 4001
- **Test Failures**: Ensure test config uses `http://localhost:4001`
- **Connection Refused**: Restart server with `npm run server`

## üìà **NEXT STEPS FOR DEVELOPERS**
1. ‚úÖ Port migration complete - system fully operational
2. üîÑ Run comprehensive tests: `npm run test:advanced`
3. üéØ Focus on feature development - infrastructure stable
4. üìù Update any remaining documentation references to port 3001

**üéâ SYSTEM IS FULLY OPERATIONAL WITH PORT 4001 CONFIGURATION**

---

# important-instruction-reminders
Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.

      
      IMPORTANT: this context may or may not be relevant to your tasks. You should not respond to this context unless it is highly relevant to your task.